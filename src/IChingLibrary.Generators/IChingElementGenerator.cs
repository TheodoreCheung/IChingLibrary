namespace IChingLibrary.Generators;

[Generator]
public class IChingElementGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. 筛选：寻找带有 [IChingEnum] 特性的 partial class
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 2. 组合：将类信息与编译信息结合
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax?>)> compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        // 3. 注册：生成源代码
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2!, spc));
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)ctx.Node;

        // 遍历类上的所有特性，检查是否是我们的 IChingEnum
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                // 使用语义模型获取特性的全名，防止同名冲突
                if (ctx.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeSymbol)
                {
                    var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                    var fullName = attributeContainingTypeSymbol.ToDisplayString();

                    if (fullName == "IChingLibrary.Core.Annotations.IChingElementEnumAttribute")
                    {
                        return classDeclarationSyntax;
                    }
                }
                // 备选方案：如果没有复杂的命名空间需求，也可以简单判断名称
                else if (attributeSyntax.Name.ToString().Contains("IChingElementEnum"))
                {
                    return classDeclarationSyntax;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        foreach (var classSyntax in classes.Distinct())
        {
            var model = compilation.GetSemanticModel(classSyntax.SyntaxTree);
            if (model.GetDeclaredSymbol(classSyntax) is not INamedTypeSymbol symbol) continue;

            // 提取信息
            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            var className = symbol.Name;

            // 找出所有 static readonly 且类型是自身的字段
            var fieldNames = symbol.GetMembers()
                .OfType<IFieldSymbol>()
                .Where(f => f.IsStatic && f.IsReadOnly && SymbolEqualityComparer.Default.Equals(f.Type, symbol))
                .Select(f => f.Name)
                .ToImmutableArray();

            if (fieldNames.Length == 0) continue;

            // 生成代码
            var source = GeneratePartialClass(namespaceName, className, fieldNames);
            context.AddSource($"{className}_Generated.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GeneratePartialClass(string ns, string className, ImmutableArray<string> fields)
    {
        var sb = new StringBuilder();
        sb.Append($$"""
                    // <auto-generated/>
                    using System;
                    using System.Collections.Generic;

                    namespace {{ns}};

                    public partial class {{className}}
                    {
                        private static readonly Dictionary<byte, {{className}}> _allElements = new Dictionary<byte, {{className}}>
                        {

                    """);
        foreach (var field in fields)
        {
            sb.AppendLine($"        {{ (byte){field}.Value, {field} }},");
        }

        sb.Append($$"""
                        };

                        public static IEnumerable<{{className}}> GetAll() => _allElements.Values;

                        public static {{className}} FromValue(byte value) 
                        {
                            return _allElements.TryGetValue(value, out var element) 
                                ? element 
                                : throw new KeyNotFoundException($"Value {value} not found in {{className}}");
                        }
                    }
                    """);
        return sb.ToString();
    }
}